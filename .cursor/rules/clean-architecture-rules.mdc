---
alwaysApply: false
---

# Clean Architecture Rules for VegetaQR

## 🚨 Các vi phạm nghiêm trọng cần tránh

### 1. **KHÔNG BAO GIỜ truy cập trực tiếp Service từ Cubit/Bloc**

```dart
// ❌ VI PHẠM - Cubit import và sử dụng trực tiếp Service
import '../../../core/services/permission_service.dart';

class PermissionsExplanationCubit extends Cubit<PermissionsExplanationState> {
  final PermissionService _permissionService; // ❌ Truy cập trực tiếp service
```

```dart
// ✅ ĐÚNG - Cubit chỉ sử dụng UseCases
import '../../../domain/usecases/request_permissions.dart';

class PermissionsExplanationCubit extends Cubit<PermissionsExplanationState> {
  final RequestPermissions _requestPermissions; // ✅ Sử dụng usecase
```

### 2. **BẮT BUỘC có Domain Layer cho mọi feature**

- ✅ Tạo Entity trong `lib/domain/entities/`
- ✅ Tạo Repository interface trong `lib/domain/repositories/`
- ✅ Tạo UseCase trong `lib/domain/usecases/`
- ❌ KHÔNG định nghĩa business logic trong Service

### 3. **Dependency Inversion Principle**

```dart
// ✅ ĐÚNG - Repository interface trong domain
abstract class PermissionRepository {
  Future<PermissionStatus> requestCameraPermission();
}

// ✅ ĐÚNG - Implementation trong data layer
class PermissionRepositoryImpl implements PermissionRepository {
  @override
  Future<PermissionStatus> requestCameraPermission() async {
    // Implementation
  }
}
```

### 4. Model phải kế thừa từ Entity

```dart
// ✅ ĐÚNG
class LegalContentModel extends LegalContent {
  const LegalContentModel({
    required super.documentType,
    required super.content,
  });

  // Các method chuyển đổi từ/to JSON
  factory LegalContentModel.fromMap(Map<String, dynamic> map) { ... }
  Map<String, dynamic> toMap() { ... }
}

// ❌ SAI
class LegalContentModel {
  final LegalDocumentType documentType;
  final String content;

  const LegalContentModel({required this.documentType, required this.content});

  // Phải có method toEntity() - không cần thiết khi kế thừa
  LegalContent toEntity() { ... }
}
```

### 5. Repository Implementation

```dart
// ✅ ĐÚNG - Trả về trực tiếp từ DataSource
class LegalRepositoryImpl implements LegalRepository {
  @override
  Future<LegalContent> getPrivacyPolicy() async {
    try {
      return await _dataSource.getPrivacyPolicy(); // Trả về trực tiếp
    } catch (e) {
      throw Exception('Failed to get privacy policy: $e');
    }
  }
}

// ❌ SAI - Gọi toEntity() không cần thiết
class LegalRepositoryImpl implements LegalRepository {
  @override
  Future<LegalContent> getPrivacyPolicy() async {
    try {
      final model = await _dataSource.getPrivacyPolicy();
      return model.toEntity(); // Không cần thiết khi Model kế thừa Entity
    } catch (e) {
      throw Exception('Failed to get privacy policy: $e');
    }
  }
}
```

### 6. DataSource Interface

```dart
// ✅ ĐÚNG - Trả về Entity type
abstract class LegalDataSource {
  Future<LegalContent> getPrivacyPolicy();
  Future<LegalContent> getTermsOfService();
}

// ❌ SAI - Trả về Model type
abstract class LegalDataSource {
  Future<LegalContentModel> getPrivacyPolicy();
  Future<LegalContentModel> getTermsOfService();
}
```

### 7. DataSource Implementation

```dart
// ✅ ĐÚNG - Trả về Model (kế thừa từ Entity)
class LegalDataSourceImpl implements LegalDataSource {
  @override
  Future<LegalContent> getLegalContent({
    required LegalDocumentType documentType,
  }) async {
    // ... logic lấy data từ Firestore
    return LegalContentModel.fromMap(data); // Trả về Model
  }
}
```

## 📋 Quy trình tạo feature mới

### Bước 1: Tạo Domain Entities

```dart
// lib/domain/entities/feature_entity.dart
class FeatureEntity extends Equatable {
  final String id;
  final String name;

  const FeatureEntity({required this.id, required this.name});

  @override
  List<Object?> get props => [id, name];
}
```

### Bước 2: Tạo Repository Interface

```dart
// lib/domain/repositories/feature_repository.dart
abstract class FeatureRepository {
  Future<List<FeatureEntity>> getFeatures();
  Future<void> saveFeature(FeatureEntity feature);
}
```

### Bước 3: Tạo UseCases

```dart
// lib/domain/usecases/get_features.dart
class GetFeatures extends UseCase<List<FeatureEntity>, NoParams> {
  final FeatureRepository repository;

  GetFeatures({required this.repository});

  @override
  Future<List<FeatureEntity>> call(NoParams params) async {
    return await repository.getFeatures();
  }
}

// lib/domain/usecases/save_feature.dart
class SaveFeature extends UseCase<void, FeatureEntity> {
  final FeatureRepository repository;

  SaveFeature({required this.repository});

  @override
  Future<void> call(FeatureEntity feature) async {
    await repository.saveFeature(feature);
  }
}
```

### Bước 4: Tạo Data Layer Implementation

```dart
// lib/data/repositories/feature_repository_impl.dart
class FeatureRepositoryImpl implements FeatureRepository {
  final FeatureDataSource dataSource;

  FeatureRepositoryImpl({required this.dataSource});

  @override
  Future<List<FeatureEntity>> getFeatures() async {
    final data = await dataSource.getFeatures();
    return data.map((e) => e.toEntity()).toList();
  }

  @override
  Future<void> saveFeature(FeatureEntity feature) async {
    final model = feature.toModel();
    await dataSource.saveFeature(model);
  }
}
```

### Bước 5: Tạo Cubit/Bloc

```dart
// lib/presentation/bloc/feature/feature_cubit.dart
class FeatureCubit extends Cubit<FeatureState> {
  final GetFeatures _getFeatures;
  final SaveFeature _saveFeature;

  FeatureCubit({
    required GetFeatures getFeatures,
    required SaveFeature saveFeature,
  }) : _getFeatures = getFeatures,
       _saveFeature = saveFeature,
       super(const FeatureInitial());

  Future<void> loadFeatures() async {
    emit(const FeatureLoading());
    try {
      final features = await _getFeatures(NoParams());
      emit(FeatureLoaded(features: features));
    } catch (e) {
      emit(FeatureError(message: e.toString()));
    }
  }

  Future<void> saveFeature(FeatureEntity feature) async {
    emit(const FeatureSaving());
    try {
      await _saveFeature(feature);
      emit(const FeatureSaved());
    } catch (e) {
      emit(FeatureError(message: e.toString()));
    }
  }
}
```

### Bước 6: Đăng ký Dependency Injection

```dart
// lib/core/dependency_injection/injection_container.dart

// UseCases
sl.registerLazySingleton(() => GetFeatures(repository: sl()));
sl.registerLazySingleton(() => SaveFeature(repository: sl()));

// Repository
sl.registerLazySingleton<FeatureRepository>(
  () => FeatureRepositoryImpl(dataSource: sl()),
);

// DataSource
sl.registerLazySingleton<FeatureDataSource>(
  () => FeatureDataSourceImpl(),
);

// Cubit
sl.registerFactory(
  () => FeatureCubit(
    getFeatures: sl(),
    saveFeature: sl(),
  ),
);
```

## 🔧 Business Logic Rules

### 1. **Cubit chỉ quản lý State, không chứa Business Logic**

```dart
// ❌ SAI - Business logic trong Cubit
Future<void> _processPermissionResults() async {
  final deniedPermissions = <Permission>[];
  // Complex business logic here...
}

// ✅ ĐÚNG - Cubit chỉ gọi UseCase
Future<void> _processPermissionResults() async {
  final result = await _processPermissionResultsUseCase(params);
  emit(FeatureState(result: result));
}
```

## 🏗️ Layer Responsibilities

### Domain Layer (lib/domain/)

- **Entities**: Pure data models, không phụ thuộc framework
- **Repositories**: Abstract interfaces định nghĩa contracts
- **UseCases**: Business logic, orchestration

### Data Layer (lib/data/)

- **Repositories**: Implementations của domain repositories
- **DataSources**: Raw data access (API, Database, etc.)
- **Models**: Data transfer objects

### Presentation Layer (lib/presentation/)

- **Cubits/Blocs**: State management, UI logic
- **Pages**: UI components
- **Widgets**: Reusable UI components

### Core Layer (lib/core/)

- **Services**: Platform-specific implementations
- **Utils**: Helper functions
- **Constants**: App-wide constants

## 🚫 Các vi phạm cần tránh

### 1. **Import sai layer**

```dart
// ❌ SAI - Presentation import Data layer
import '../../data/repositories/feature_repository_impl.dart';

// ✅ ĐÚNG - Presentation chỉ import Domain
import '../../domain/repositories/feature_repository.dart';
```

### 2. **Business logic trong UI**

```dart
// ❌ SAI - Business logic trong Widget
Widget build(BuildContext context) {
  if (permissionStatus.isGranted && photosStatus.isGranted) {
    // Business logic here
  }
}

// ✅ ĐÚNG - UI chỉ hiển thị state
Widget build(BuildContext context) {
  return BlocBuilder<FeatureCubit, FeatureState>(
    builder: (context, state) {
      if (state is FeatureCompleted) {
        return SuccessWidget();
      }
    },
  );
}
```

## 📝 Checklist khi tạo feature mới

- [ ] Tạo Entity trong domain layer
- [ ] Tạo Repository interface trong domain layer
- [ ] Tạo UseCase(s) trong domain layer
- [ ] Tạo Repository implementation trong data layer
- [ ] Tạo DataSource nếu cần
- [ ] Tạo Cubit/Bloc chỉ sử dụng UseCases
- [ ] Đăng ký tất cả dependencies trong injection_container.dart
- [ ] KHÔNG import service trực tiếp vào Cubit
- [ ] KHÔNG viết business logic trong Cubit

## 🔍 Code Review Checklist

Khi review code, kiểm tra:

1. **Cubit có import service không?** → Phải sử dụng UseCase
2. **Business logic có trong Cubit không?** → Phải chuyển sang UseCase
3. **Có Entity trong domain không?** → Phải có
4. **Có Repository interface không?** → Phải có
5. **Dependency injection đã đăng ký đầy đủ chưa?** → Phải có
6. **Import có đúng layer không?** → Presentation chỉ import Domain

## 🎯 Lợi ích của Clean Architecture

1. **Testability**: Dễ test từng layer riêng biệt
2. **Maintainability**: Code dễ bảo trì và mở rộng
3. **Flexibility**: Dễ thay đổi implementation mà không ảnh hưởng business logic
4. **Scalability**: Dễ thêm features mới
5. **Team Collaboration**: Mỗi developer có thể làm việc trên layer khác nhau

---

**Lưu ý**: Tuân thủ nghiêm ngặt các rule này để đảm bảo code quality và maintainability của dự án.
