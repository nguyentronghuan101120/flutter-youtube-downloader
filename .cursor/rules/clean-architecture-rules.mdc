---
alwaysApply: false
---

# Clean Architecture Rules for VegetaQR

## ğŸš¨ CÃ¡c vi pháº¡m nghiÃªm trá»ng cáº§n trÃ¡nh

### 1. **KHÃ”NG BAO GIá»œ truy cáº­p trá»±c tiáº¿p Service tá»« Cubit/Bloc**

```dart
// âŒ VI PHáº M - Cubit import vÃ  sá»­ dá»¥ng trá»±c tiáº¿p Service
import '../../../core/services/permission_service.dart';

class PermissionsExplanationCubit extends Cubit<PermissionsExplanationState> {
  final PermissionService _permissionService; // âŒ Truy cáº­p trá»±c tiáº¿p service
```

```dart
// âœ… ÄÃšNG - Cubit chá»‰ sá»­ dá»¥ng UseCases
import '../../../domain/usecases/request_permissions.dart';

class PermissionsExplanationCubit extends Cubit<PermissionsExplanationState> {
  final RequestPermissions _requestPermissions; // âœ… Sá»­ dá»¥ng usecase
```

### 2. **Báº®T BUá»˜C cÃ³ Domain Layer cho má»i feature**

- âœ… Táº¡o Entity trong `lib/domain/entities/`
- âœ… Táº¡o Repository interface trong `lib/domain/repositories/`
- âœ… Táº¡o UseCase trong `lib/domain/usecases/`
- âŒ KHÃ”NG Ä‘á»‹nh nghÄ©a business logic trong Service

### 3. **Dependency Inversion Principle**

```dart
// âœ… ÄÃšNG - Repository interface trong domain
abstract class PermissionRepository {
  Future<PermissionStatus> requestCameraPermission();
}

// âœ… ÄÃšNG - Implementation trong data layer
class PermissionRepositoryImpl implements PermissionRepository {
  @override
  Future<PermissionStatus> requestCameraPermission() async {
    // Implementation
  }
}
```

### 4. Model pháº£i káº¿ thá»«a tá»« Entity

```dart
// âœ… ÄÃšNG
class LegalContentModel extends LegalContent {
  const LegalContentModel({
    required super.documentType,
    required super.content,
  });

  // CÃ¡c method chuyá»ƒn Ä‘á»•i tá»«/to JSON
  factory LegalContentModel.fromMap(Map<String, dynamic> map) { ... }
  Map<String, dynamic> toMap() { ... }
}

// âŒ SAI
class LegalContentModel {
  final LegalDocumentType documentType;
  final String content;

  const LegalContentModel({required this.documentType, required this.content});

  // Pháº£i cÃ³ method toEntity() - khÃ´ng cáº§n thiáº¿t khi káº¿ thá»«a
  LegalContent toEntity() { ... }
}
```

### 5. Repository Implementation

```dart
// âœ… ÄÃšNG - Tráº£ vá» trá»±c tiáº¿p tá»« DataSource
class LegalRepositoryImpl implements LegalRepository {
  @override
  Future<LegalContent> getPrivacyPolicy() async {
    try {
      return await _dataSource.getPrivacyPolicy(); // Tráº£ vá» trá»±c tiáº¿p
    } catch (e) {
      throw Exception('Failed to get privacy policy: $e');
    }
  }
}

// âŒ SAI - Gá»i toEntity() khÃ´ng cáº§n thiáº¿t
class LegalRepositoryImpl implements LegalRepository {
  @override
  Future<LegalContent> getPrivacyPolicy() async {
    try {
      final model = await _dataSource.getPrivacyPolicy();
      return model.toEntity(); // KhÃ´ng cáº§n thiáº¿t khi Model káº¿ thá»«a Entity
    } catch (e) {
      throw Exception('Failed to get privacy policy: $e');
    }
  }
}
```

### 6. DataSource Interface

```dart
// âœ… ÄÃšNG - Tráº£ vá» Entity type
abstract class LegalDataSource {
  Future<LegalContent> getPrivacyPolicy();
  Future<LegalContent> getTermsOfService();
}

// âŒ SAI - Tráº£ vá» Model type
abstract class LegalDataSource {
  Future<LegalContentModel> getPrivacyPolicy();
  Future<LegalContentModel> getTermsOfService();
}
```

### 7. DataSource Implementation

```dart
// âœ… ÄÃšNG - Tráº£ vá» Model (káº¿ thá»«a tá»« Entity)
class LegalDataSourceImpl implements LegalDataSource {
  @override
  Future<LegalContent> getLegalContent({
    required LegalDocumentType documentType,
  }) async {
    // ... logic láº¥y data tá»« Firestore
    return LegalContentModel.fromMap(data); // Tráº£ vá» Model
  }
}
```

## ğŸ“‹ Quy trÃ¬nh táº¡o feature má»›i

### BÆ°á»›c 1: Táº¡o Domain Entities

```dart
// lib/domain/entities/feature_entity.dart
class FeatureEntity extends Equatable {
  final String id;
  final String name;

  const FeatureEntity({required this.id, required this.name});

  @override
  List<Object?> get props => [id, name];
}
```

### BÆ°á»›c 2: Táº¡o Repository Interface

```dart
// lib/domain/repositories/feature_repository.dart
abstract class FeatureRepository {
  Future<List<FeatureEntity>> getFeatures();
  Future<void> saveFeature(FeatureEntity feature);
}
```

### BÆ°á»›c 3: Táº¡o UseCases

```dart
// lib/domain/usecases/get_features.dart
class GetFeatures extends UseCase<List<FeatureEntity>, NoParams> {
  final FeatureRepository repository;

  GetFeatures({required this.repository});

  @override
  Future<List<FeatureEntity>> call(NoParams params) async {
    return await repository.getFeatures();
  }
}

// lib/domain/usecases/save_feature.dart
class SaveFeature extends UseCase<void, FeatureEntity> {
  final FeatureRepository repository;

  SaveFeature({required this.repository});

  @override
  Future<void> call(FeatureEntity feature) async {
    await repository.saveFeature(feature);
  }
}
```

### BÆ°á»›c 4: Táº¡o Data Layer Implementation

```dart
// lib/data/repositories/feature_repository_impl.dart
class FeatureRepositoryImpl implements FeatureRepository {
  final FeatureDataSource dataSource;

  FeatureRepositoryImpl({required this.dataSource});

  @override
  Future<List<FeatureEntity>> getFeatures() async {
    final data = await dataSource.getFeatures();
    return data.map((e) => e.toEntity()).toList();
  }

  @override
  Future<void> saveFeature(FeatureEntity feature) async {
    final model = feature.toModel();
    await dataSource.saveFeature(model);
  }
}
```

### BÆ°á»›c 5: Táº¡o Cubit/Bloc

```dart
// lib/presentation/bloc/feature/feature_cubit.dart
class FeatureCubit extends Cubit<FeatureState> {
  final GetFeatures _getFeatures;
  final SaveFeature _saveFeature;

  FeatureCubit({
    required GetFeatures getFeatures,
    required SaveFeature saveFeature,
  }) : _getFeatures = getFeatures,
       _saveFeature = saveFeature,
       super(const FeatureInitial());

  Future<void> loadFeatures() async {
    emit(const FeatureLoading());
    try {
      final features = await _getFeatures(NoParams());
      emit(FeatureLoaded(features: features));
    } catch (e) {
      emit(FeatureError(message: e.toString()));
    }
  }

  Future<void> saveFeature(FeatureEntity feature) async {
    emit(const FeatureSaving());
    try {
      await _saveFeature(feature);
      emit(const FeatureSaved());
    } catch (e) {
      emit(FeatureError(message: e.toString()));
    }
  }
}
```

### BÆ°á»›c 6: ÄÄƒng kÃ½ Dependency Injection

```dart
// lib/core/dependency_injection/injection_container.dart

// UseCases
sl.registerLazySingleton(() => GetFeatures(repository: sl()));
sl.registerLazySingleton(() => SaveFeature(repository: sl()));

// Repository
sl.registerLazySingleton<FeatureRepository>(
  () => FeatureRepositoryImpl(dataSource: sl()),
);

// DataSource
sl.registerLazySingleton<FeatureDataSource>(
  () => FeatureDataSourceImpl(),
);

// Cubit
sl.registerFactory(
  () => FeatureCubit(
    getFeatures: sl(),
    saveFeature: sl(),
  ),
);
```

## ğŸ”§ Business Logic Rules

### 1. **Cubit chá»‰ quáº£n lÃ½ State, khÃ´ng chá»©a Business Logic**

```dart
// âŒ SAI - Business logic trong Cubit
Future<void> _processPermissionResults() async {
  final deniedPermissions = <Permission>[];
  // Complex business logic here...
}

// âœ… ÄÃšNG - Cubit chá»‰ gá»i UseCase
Future<void> _processPermissionResults() async {
  final result = await _processPermissionResultsUseCase(params);
  emit(FeatureState(result: result));
}
```

## ğŸ—ï¸ Layer Responsibilities

### Domain Layer (lib/domain/)

- **Entities**: Pure data models, khÃ´ng phá»¥ thuá»™c framework
- **Repositories**: Abstract interfaces Ä‘á»‹nh nghÄ©a contracts
- **UseCases**: Business logic, orchestration

### Data Layer (lib/data/)

- **Repositories**: Implementations cá»§a domain repositories
- **DataSources**: Raw data access (API, Database, etc.)
- **Models**: Data transfer objects

### Presentation Layer (lib/presentation/)

- **Cubits/Blocs**: State management, UI logic
- **Pages**: UI components
- **Widgets**: Reusable UI components

### Core Layer (lib/core/)

- **Services**: Platform-specific implementations
- **Utils**: Helper functions
- **Constants**: App-wide constants

## ğŸš« CÃ¡c vi pháº¡m cáº§n trÃ¡nh

### 1. **Import sai layer**

```dart
// âŒ SAI - Presentation import Data layer
import '../../data/repositories/feature_repository_impl.dart';

// âœ… ÄÃšNG - Presentation chá»‰ import Domain
import '../../domain/repositories/feature_repository.dart';
```

### 2. **Business logic trong UI**

```dart
// âŒ SAI - Business logic trong Widget
Widget build(BuildContext context) {
  if (permissionStatus.isGranted && photosStatus.isGranted) {
    // Business logic here
  }
}

// âœ… ÄÃšNG - UI chá»‰ hiá»ƒn thá»‹ state
Widget build(BuildContext context) {
  return BlocBuilder<FeatureCubit, FeatureState>(
    builder: (context, state) {
      if (state is FeatureCompleted) {
        return SuccessWidget();
      }
    },
  );
}
```

## ğŸ“ Checklist khi táº¡o feature má»›i

- [ ] Táº¡o Entity trong domain layer
- [ ] Táº¡o Repository interface trong domain layer
- [ ] Táº¡o UseCase(s) trong domain layer
- [ ] Táº¡o Repository implementation trong data layer
- [ ] Táº¡o DataSource náº¿u cáº§n
- [ ] Táº¡o Cubit/Bloc chá»‰ sá»­ dá»¥ng UseCases
- [ ] ÄÄƒng kÃ½ táº¥t cáº£ dependencies trong injection_container.dart
- [ ] KHÃ”NG import service trá»±c tiáº¿p vÃ o Cubit
- [ ] KHÃ”NG viáº¿t business logic trong Cubit

## ğŸ” Code Review Checklist

Khi review code, kiá»ƒm tra:

1. **Cubit cÃ³ import service khÃ´ng?** â†’ Pháº£i sá»­ dá»¥ng UseCase
2. **Business logic cÃ³ trong Cubit khÃ´ng?** â†’ Pháº£i chuyá»ƒn sang UseCase
3. **CÃ³ Entity trong domain khÃ´ng?** â†’ Pháº£i cÃ³
4. **CÃ³ Repository interface khÃ´ng?** â†’ Pháº£i cÃ³
5. **Dependency injection Ä‘Ã£ Ä‘Äƒng kÃ½ Ä‘áº§y Ä‘á»§ chÆ°a?** â†’ Pháº£i cÃ³
6. **Import cÃ³ Ä‘Ãºng layer khÃ´ng?** â†’ Presentation chá»‰ import Domain

## ğŸ¯ Lá»£i Ã­ch cá»§a Clean Architecture

1. **Testability**: Dá»… test tá»«ng layer riÃªng biá»‡t
2. **Maintainability**: Code dá»… báº£o trÃ¬ vÃ  má»Ÿ rá»™ng
3. **Flexibility**: Dá»… thay Ä‘á»•i implementation mÃ  khÃ´ng áº£nh hÆ°á»Ÿng business logic
4. **Scalability**: Dá»… thÃªm features má»›i
5. **Team Collaboration**: Má»—i developer cÃ³ thá»ƒ lÃ m viá»‡c trÃªn layer khÃ¡c nhau

---

**LÆ°u Ã½**: TuÃ¢n thá»§ nghiÃªm ngáº·t cÃ¡c rule nÃ y Ä‘á»ƒ Ä‘áº£m báº£o code quality vÃ  maintainability cá»§a dá»± Ã¡n.
